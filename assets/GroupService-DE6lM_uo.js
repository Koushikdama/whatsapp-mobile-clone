import{F as t,d as s,e as a,g as e,s as r,h as c,i as n,k as i,w as o,l as u,m as d}from"./index-BvqpNl34.js";const p=new class extends t{constructor(){super(),this.collectionName="groups"}async updateGroupInfo(t,n){try{const c=s(a,this.collectionName,t),i=["name","description","avatar"],o=Object.keys(n).filter(t=>i.includes(t)).reduce((t,s)=>(t[s]=n[s],t),{});return 0===Object.keys(o).length?{success:!1,error:"No valid fields to update"}:(await e(c,{...o,updatedAt:r()}),{success:!0})}catch(i){throw c(i)}}async updateGroupPermissions(t,n){try{const c=s(a,this.collectionName,t);return await e(c,{permissions:n,updatedAt:r()}),{success:!0}}catch(i){throw c(i)}}async addParticipant(t,o){try{const c=s(a,this.collectionName,t),u=await n(c);if(!u.exists())return{success:!1,error:"Group not found"};return(u.data().participants||[]).includes(o)?{success:!1,error:"User is already a participant"}:(await e(c,{participants:i(o),updatedAt:r()}),{success:!0})}catch(u){throw c(u)}}async removeParticipant(t,e){try{const c=o(a),n=s(a,this.collectionName,t);return c.update(n,{participants:u(e),admins:u(e),updatedAt:r()}),await c.commit(),{success:!0}}catch(n){throw c(n)}}async promoteToAdmin(t,o){try{const c=s(a,this.collectionName,t),u=await n(c);if(!u.exists())return{success:!1,error:"Group not found"};const d=u.data().participants||[],p=u.data().admins||[];return d.includes(o)?p.includes(o)?{success:!1,error:"User is already an admin"}:(await e(c,{admins:i(o),updatedAt:r()}),{success:!0}):{success:!1,error:"User is not a participant"}}catch(u){throw c(u)}}async demoteFromAdmin(t,n){try{const c=s(a,this.collectionName,t);return await e(c,{admins:u(n),updatedAt:r()}),{success:!0}}catch(i){throw c(i)}}async transferOwnership(t,e,u){try{const c=o(a),d=s(a,this.collectionName,t),p=await n(d);if(!p.exists())return{success:!1,error:"Group not found"};return(p.data().participants||[]).includes(e)?(c.update(d,{owner:e,admins:i(e,u),updatedAt:r()}),await c.commit(),{success:!0}):{success:!1,error:"New owner must be a participant"}}catch(d){throw c(d)}}async leaveGroup(t,e){try{const r=await n(s(a,this.collectionName,t));if(!r.exists())return{success:!1,error:"Group not found"};return r.data().owner===e?{success:!1,error:"Owner must transfer ownership before leaving"}:(await this.removeParticipant(t,e),{success:!0})}catch(r){throw c(r)}}async deleteGroup(t){try{const e=s(a,this.collectionName,t);return await d(e),{success:!0}}catch(e){throw c(e)}}async muteGroup(t,n){try{const c=s(a,this.collectionName,t),i=n?new Date(Date.now()+n):null;return await e(c,{"settings.muteUntil":i,updatedAt:r()}),{success:!0}}catch(i){throw c(i)}}async isAdmin(t,e){try{const r=await n(s(a,this.collectionName,t));if(!r.exists())return!1;return(r.data().admins||[]).includes(e)||r.data().owner===e}catch(r){return!1}}async isOwner(t,e){try{const r=await n(s(a,this.collectionName,t));return!!r.exists()&&r.data().owner===e}catch(r){return!1}}};export{p as g};
