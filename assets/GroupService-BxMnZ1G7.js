const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-7VfhOhEA.js","assets/router-BlRKbG7o.js","assets/react-vendor-Dp0kJvEn.js","assets/icons-FsuYV2CB.js","assets/lottie-BmTBBIiw.js","assets/chess-Bi0BiJQc.js","assets/index-CncLY5ce.css"])))=>i.map(i=>d[i]);
import{F as t,_ as s,d as e,e as a,g as r,s as c,h as i,i as n,k as o,N as u,w as d,l as p,m as h}from"./index-7VfhOhEA.js";const l=new class extends t{constructor(){super(),this.collectionName="groups",this.unifiedNotificationService=null}async getNotificationService(){if(!this.unifiedNotificationService){const t=await s(()=>import("./index-7VfhOhEA.js").then(t=>t.U),__vite__mapDeps([0,1,2,3,4,5,6]));this.unifiedNotificationService=t.default}return this.unifiedNotificationService}async updateGroupInfo(t,s){try{const i=e(a,this.collectionName,t),n=["name","description","avatar"],o=Object.keys(s).filter(t=>n.includes(t)).reduce((t,e)=>(t[e]=s[e],t),{});return 0===Object.keys(o).length?{success:!1,error:"No valid fields to update"}:(await r(i,{...o,updatedAt:c()}),{success:!0})}catch(n){throw i(n)}}async updateGroupPermissions(t,s){try{const i=e(a,this.collectionName,t);return await r(i,{permissions:s,updatedAt:c()}),{success:!0}}catch(n){throw i(n)}}async updateGroupSettings(t,s){try{if(!t)return{success:!1,error:"Group ID is required"};const i=e(a,this.collectionName,t);if(!(await n(i)).exists())return{success:!1,error:"Group not found"};const o={};return Object.keys(s).forEach(t=>{o[`settings.${t}`]=s[t]}),await r(i,{...o,updatedAt:c()}),{success:!0}}catch(o){throw i(o)}}async addParticipant(t,s){try{const i=e(a,this.collectionName,t),p=await n(i);if(!p.exists())return{success:!1,error:"Group not found"};if((p.data().participants||[]).includes(s))return{success:!1,error:"User is already a participant"};await r(i,{participants:o(s),updatedAt:c()});try{const e=await this.getNotificationService(),a=p.data().owner||"admin";await e.sendNotification(s,a,u.ADDED_TO_GROUP,{groupId:t,groupName:p.data().name||"a group"})}catch(d){}return{success:!0}}catch(p){throw i(p)}}async removeParticipant(t,s){try{const r=d(a),i=e(a,this.collectionName,t);return r.update(i,{participants:p(s),admins:p(s),updatedAt:c()}),await r.commit(),{success:!0}}catch(r){throw i(r)}}async promoteToAdmin(t,s){try{const i=e(a,this.collectionName,t),u=await n(i);if(!u.exists())return{success:!1,error:"Group not found"};const d=u.data().participants||[],p=u.data().admins||[];return d.includes(s)?p.includes(s)?{success:!1,error:"User is already an admin"}:(await r(i,{admins:o(s),updatedAt:c()}),{success:!0}):{success:!1,error:"User is not a participant"}}catch(u){throw i(u)}}async demoteFromAdmin(t,s){try{const i=e(a,this.collectionName,t);return await r(i,{admins:p(s),updatedAt:c()}),{success:!0}}catch(n){throw i(n)}}async transferOwnership(t,s,r){try{const i=d(a),u=e(a,this.collectionName,t),p=await n(u);if(!p.exists())return{success:!1,error:"Group not found"};return(p.data().participants||[]).includes(s)?(i.update(u,{owner:s,admins:o(s,r),updatedAt:c()}),await i.commit(),{success:!0}):{success:!1,error:"New owner must be a participant"}}catch(u){throw i(u)}}async leaveGroup(t,s){try{const r=await n(e(a,this.collectionName,t));if(!r.exists())return{success:!1,error:"Group not found"};return r.data().owner===s?{success:!1,error:"Owner must transfer ownership before leaving"}:(await this.removeParticipant(t,s),{success:!0})}catch(r){throw i(r)}}async deleteGroup(t){try{const s=e(a,this.collectionName,t);return await h(s),{success:!0}}catch(s){throw i(s)}}async muteGroup(t,s){try{const i=e(a,this.collectionName,t),n=s?new Date(Date.now()+s):null;return await r(i,{"settings.muteUntil":n,updatedAt:c()}),{success:!0}}catch(n){throw i(n)}}async isAdmin(t,s){try{const r=await n(e(a,this.collectionName,t));if(!r.exists())return!1;return(r.data().admins||[]).includes(s)||r.data().owner===s}catch(r){return!1}}async isOwner(t,s){try{const r=await n(e(a,this.collectionName,t));return!!r.exists()&&r.data().owner===s}catch(r){return!1}}};export{l as g};
